const fs = require('fs');
const path = require('path');

const ROOT = __dirname;
const SRC_RI = path.join(ROOT, 'ri');
const DIST = path.join(ROOT, 'dist');
const DIST_RI = path.join(DIST, 'ri');
const CONFIG_FILE = path.join(ROOT, 'config.json');

// Helper: Shuffle Array (Fisher-Yates)
function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

// Main function
function build() {
    console.log('Starting build...');

    // Load Config
    let config = { domain: '' };
    
    // Priority 1: Environment Variable
    if (process.env.DOMAIN) {
        config.domain = process.env.DOMAIN;
        console.log('Loaded domain from environment variable.');
    } 
    // Priority 2: Config File
    else if (fs.existsSync(CONFIG_FILE)) {
        try {
            const configContent = fs.readFileSync(CONFIG_FILE, 'utf8');
            const parsed = JSON.parse(configContent);
            if (parsed.domain) {
                config.domain = parsed.domain;
            }
            console.log('Loaded domain from config.json.');
        } catch (e) {
            console.warn('Failed to parse config.json, using default settings.');
        }
    }

    // Normalize domain (remove trailing slash)
    if (config.domain) {
        config.domain = config.domain.replace(/\/$/, '');
    }

    console.log(`Using domain prefix: "${config.domain}"`);

    // 1. Clean/Create Dist
    if (fs.existsSync(DIST)) {
        fs.rmSync(DIST, { recursive: true, force: true });
    }
    fs.mkdirSync(DIST, { recursive: true });
    fs.mkdirSync(DIST_RI, { recursive: true });

    // 2. Process Folders
    const types = ['h', 'v'];
    let counts = {};
    
    types.forEach(type => {
        const srcFolder = path.join(SRC_RI, type);
        const distFolder = path.join(DIST_RI, type);
        
        if (!fs.existsSync(srcFolder)) {
            console.warn(`Source folder not found: ${srcFolder}`);
            counts[type] = 0;
            return;
        }

        fs.mkdirSync(distFolder, { recursive: true });

        // Read and Filter Images
        let files = fs.readdirSync(srcFolder).filter(f => f.match(/\.(webp|jpg|jpeg|png|gif)$/i));
        
        // Shuffle
        files = shuffle(files);

        // Copy and Rename
        files.forEach((file, index) => {
            const srcPath = path.join(srcFolder, file);
            const destPath = path.join(distFolder, `${index + 1}.webp`);
            fs.copyFileSync(srcPath, destPath);
        });

        counts[type] = files.length;
        console.log(`Processed ${type}: ${counts[type]} images.`);
    });

    // 3. Generate Single JS
    const jsContent = `
/**
 * Static Random Pic API
 * Generated by build script
 */
(function() {
    var counts = ${JSON.stringify(counts)};
    var domain = '${config.domain}';
    
    // State management for session consistency
    var sessionRandomH = null;
    var sessionRandomV = null;

    // Helper: Get random URL for a type (h or v), persistent per session
    function getRandomUrl(type) {
        if (!counts[type] || counts[type] === 0) return '';
        
        // Return existing session URL if available
        if (type === 'h' && sessionRandomH) return sessionRandomH;
        if (type === 'v' && sessionRandomV) return sessionRandomV;

        // Generate new if not exists
        var num = Math.floor(Math.random() * counts[type]) + 1;
        var url = domain + '/ri/' + type + '/' + num + '.webp';

        // Save to session state
        if (type === 'h') sessionRandomH = url;
        if (type === 'v') sessionRandomV = url;

        return url;
    }

    // Expose global functions
    window.getRandomPicH = function() { return getRandomUrl('h'); };
    window.getRandomPicV = function() { return getRandomUrl('v'); };

    // Detect device type based on user agent
    function detectDeviceType() {
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        
        // Mobile device detection
        var isMobile = /android|avantgo|blackberry|bolt|boost|cricket|docomo|fone|hiptop|mini|mobi|palm|phone|pie|tablet|up\.browser|up\.link|webos|wifi/i.test(userAgent);
        
        // Tablet detection
        var isTablet = /(ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/i.test(userAgent);
        
        // Desktop detection
        var isDesktop = !isMobile && !isTablet;
        
        console.log('User Agent:', userAgent);
        console.log('Device Detection - Mobile:', isMobile, 'Tablet:', isTablet, 'Desktop:', isDesktop);
        
        // Return appropriate image type
        if (isMobile) {
            return 'v'; // Vertical for mobile devices
        } else if (isTablet) {
            // For tablets, check screen orientation
            return window.innerHeight > window.innerWidth ? 'v' : 'h';
        } else {
            return 'h'; // Horizontal for desktop by default
        }
    }

    // Set random image based on device type
    function setRandomImage() {
        var deviceType = detectDeviceType();
        console.log('Selected image type:', deviceType);
        
        var imageUrl = getRandomUrl(deviceType);
        if (!imageUrl) {
            console.error('No images available for type:', deviceType);
            return;
        }

        var imgElement = document.getElementById('random-image');
        if (!imgElement) {
            console.error('Image element not found');
            return;
        }

        // Preload image
        var img = new Image();
        img.onload = function() {
            imgElement.src = imageUrl;
            imgElement.style.opacity = '1';
            console.log('Random image loaded:', imageUrl);
        };
        img.onerror = function() {
            console.error('Failed to load image:', imageUrl);
            // Fallback to other type if available
            var fallbackType = deviceType === 'h' ? 'v' : 'h';
            var fallbackUrl = getRandomUrl(fallbackType);
            if (fallbackUrl) {
                imgElement.src = fallbackUrl;
                console.log('Using fallback image:', fallbackUrl);
            }
        };
        img.src = imageUrl;
    }

    // Handle window resize for orientation changes
    function handleResize() {
        var resizeTimeout;
        return function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // Reset session state to get new random image on orientation change
                sessionRandomH = null;
                sessionRandomV = null;
                setRandomImage();
            }, 250);
        };
    }

    function init() {
        setRandomImage();
        
        // Add resize listener for orientation changes
        window.addEventListener('resize', handleResize());
        
        // Add click to refresh functionality
        var imgElement = document.getElementById('random-image');
        if (imgElement) {
            imgElement.addEventListener('click', function() {
                // Reset session state to get new random image
                sessionRandomH = null;
                sessionRandomV = null;
                imgElement.style.opacity = '0';
                setTimeout(setRandomImage, 300);
            });
        }
    }

    // Run on initial load 
    if (document.readyState === 'loading') { 
        document.addEventListener('DOMContentLoaded', init); 
    } else { 
        init(); 
    }

    // Swup integration
    function setupSwup() {
        if (window.swup && window.swup.hooks) {
            window.swup.hooks.on('content:replace', init);
            console.log('Random Pic API: Registered with Swup hooks.');
        }
    }

    if (window.swup) {
        setupSwup();
    } else {
        document.addEventListener('swup:enable', setupSwup);
    }

    // Legacy Swup support
    document.addEventListener('swup:contentReplaced', init); 
})();
`;
    fs.writeFileSync(path.join(DIST, 'random.js'), jsContent.trim());

    // Create minimal HTML file
    createMinimalHtml();
    
    console.log('Build complete. Output is in /dist folder.');
}

function createMinimalHtml() {
    const htmlContent = `<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Image</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            cursor: pointer;
        }
        
        #random-image {
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: sans-serif;
            font-size: 16px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="loading">Loading...</div>
    
    
    <script src="random.js"></script>
    
    <script>
        // Remove loading text once image is loaded
        document.getElementById('random-image').addEventListener('load', function() {
            var loading = document.querySelector('.loading');
            if (loading) loading.style.display = 'none';
        });
    </script>
</body>
</html>`;
    
    fs.writeFileSync(path.join(DIST, 'index.html'), htmlContent);
    console.log('Created minimal image-only HTML in dist');
}

build();
